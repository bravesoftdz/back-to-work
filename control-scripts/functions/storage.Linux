#!/bin/dash

case $1 in
 start)
   # start network

   i=0
   eval ip=\$ip_$i
   while [ -n "$ip" ] ; do
      eval prefix=\$prefix_$i
      eval netdev=\$netdev_$i

      if arping -q -c 2 -w 3 -D -I $netdev $ip ; then
         ip addr add $ip/$prefix dev $netdev
         arping -q -U -c 2 -I $netdev $ip
      else
         #ip address in use
         echo "$(date) ip address $ip is in use."
         exit 1
      fi

      i=$(($i+1))
      eval ip=\$ip_$i
   done

   # start storage
   touch /tmp/$(basename $0).started
   
   i=0
   eval lun=\$lun_$i

   #key=$(gethostip -x $HOSTNAME)
   #try to avoid requiring gethostip to get ip addr in hex
   key=$(host $HOSTNAME | head -1 | tr . " ")
   key=${key#$HOSTNAME has address }
   key=$(eval printf %02x%02x%02x%02x $key)

   while [ -n "$lun" ] ; do
      #reserve
      #echo sg_persist --no-inquiry --out --register --param-aptpl --param-sark=$key --device=$lun >&2
      #echo sg_persist --no-inquiry --out --reserve --prout-type=5 --param-rk=$key --device=$lun >&2

      #release
      #echo sg_persist --no-inquiry --out --release --prout-type=5 --param-rk=$key --device=$lun >&2
      #echo sg_persist --no-inquiry --out --register --param-aptpl --param-rk=$key --param-sark=0 --device=$lun >&2

      #check
      #sg_persist --no-inquiry --read-reservation --device=$lun | grep -q "^[[:space:]]*Key=0x$key"
      #sg_persist --no-inquiry --read-keys --device=$lun | grep -q "^[[:space:]]*0x$key"
      
      i=$(($i+1))
      eval lun=\$lun_$i
   done

   # start programs

   exit 0
 ;;

 stop)
   rm /tmp/$(basename $0).started

   # stop programs
   
   # stop storage

   # stop network
   i=0
   eval ip=\$ip_$i
   while [ -n "$ip" ] ; do
      eval prefix=\$prefix_$i
      eval netdev=\$netdev_$i

      if ip addr show dev $netdev | grep -q -F " $ip/$prefix " ; then
         ip addr del $ip/$prefix dev $netdev
      fi

      i=$(($i+1))
      eval ip=\$ip_$i
   done

   exit 0
 ;;

 status)
   num_check=2
   failed_check=2

   # can return 3 values: 0 up, 1 down, 2 degraded
   
   # monitor programs
   if [ -f /tmp/$(basename $0).started ] ; then
      failed_check=$(($failed_check-1))
   fi
   
   # monitor storage
   if [ -f /tmp/$(basename $0).started ] ; then
      failed_check=$(($failed_check-1))
   fi

   # monitor network
   i=0
   eval ip=\$ip_$i
   while [ -n "$ip" ] ; do
      num_check=$(($num_check+1))
      failed_check=$(($failed_check+1))

      eval prefix=\$prefix_$i
      eval netdev=\$netdev_$i

      if ip addr show dev $netdev | grep -q -F " $ip/$prefix " ; then
         failed_check=$(($failed_check-1))
      fi

      i=$(($i+1))
      eval ip=\$ip_$i
   done
   #num_check=$((num_check+$i-1))
   #failed_check=$(($failed_check+$i-1))

   [ "$failed_check" -eq "$num_check" ] && exit 1
   [ "$failed_check" -eq "0" ] && exit 0
   exit 2
 ;;

 fence)
   echo fence ok
 ;;

 echo)
   eval echo \$$2
 ;;
 *)
   echo "Usage: ${0##*/} { start | stop | status }"
   echo "This is the custom script for your failover package."
   echo "Usually this script is called by pkg-mon service."
 ;;
esac
