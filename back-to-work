#!/bin/sh

#Copyright (c) 2014 Luigi Tarenga <luigi.tarenga@gmail.com>
#Distributed under the terms of a MIT license.

export LANG=C

cd ${0%/*}
[ -f conf/lock_path ] && read lock_path < conf/lock_path
PATH=${lock_path:-../dex-lock}:$PATH

if [ ! -x  ${lock_path:-../dex-lock}/get-lock ] ; then
   echo "back-to-work need dex-lock to run. install it and configure its location."
   exit 1
fi
unset lock_path

package=$1
if [ -z "$package" ] ; then
   echo "Usage: ${0##*/} { package-name}"
   echo "  This is the cluster package monitor. It can run on multiple node and only"
   echo "  one instance switch from stand-by to active state to start the package"
   echo "  services. The active one will poll and monitor the health of the package"
   echo "  and in case of failure will shutdown it letting another monitor to try"
   echo "  to start it again on another node."
   echo "  Usually it's started with the \"service start <packag-name>\" command."
   exit 0
fi

read_conf () {
   pace=$(packages/$package echo pace); pace=${pace:-4}
   timeout=$(packages/$package echo timeout); timeout=${timeout:-30}
   timeout2=$(packages/$package echo stop_timeout); timeout2=${timeout2:-30}
   start_timeout=$(packages/$package echo start_timeout); start_timeout=${start_timeout:-30}
   stop_timeout=$timeout2
   shell_cmd=$(head -1 packages/$package); shell_cmd=${shell_cmd#\#!}
}

quit () {
   rmdir temp/monitor_lockdir_$package
   release-lock $package
   exit $1
}

#do not immediately exit on kill! we must stop the package before quitting!
trap 'echo "$(date) received signal SIGHUP. starting halt sequence." ; stop="true"' HUP
trap 'echo "$(date) received signal SIGINT. starting halt sequence." ; stop="true"' INT
trap 'echo "$(date) received signal SIGTERM. starting halt sequence." ; stop="true"' TERM
trap 'echo "$(date) received signal SIGUSR1. re-reading package parameters." ; read_conf' USR1

if ! mkdir temp/monitor_lockdir_$package 2> /dev/null ; then
   echo "temp/monitor_lockdir_$1 already exist. back-to-work is already running for package $1."
   exit 1
fi

read_conf
role="stand-by"
stop="false"

init-lock $package $timeout $timeout2

###############################################
#these function are here to speed up the parser 

_starting () {
   if ! kill -0 $start_pid 2> /dev/null ; then
      wait $start_pid
      if [ $? -eq 0 ] ; then
         packages/$package status >> log/$package.log 2>&1 & status_pid=$!
         pkg_state="running"
      else
         echo "$(date) start script exited with error."
         packages/$package stop >> log/$package.log 2>&1 & stop_pid=$!
         pkg_state="failing"
      fi
   else
      start_timeout=$((start_timeout-pace))
   fi

   if [ $start_timeout -le 0 ] ; then
      echo "$(date) timeout waiting for package to start."
      kill $start_pid
      packages/$package stop >> log/$package.log 2>&1 & stop_pid=$!
      pkg_state="failing"
   fi
}

_running () {
   if ! kill -0 $status_pid 2> /dev/null ; then
      wait $status_pid
      pkg_status=$?

      #status function returns: 0 up, 1 down, 2 degraded, 3 critical
      case "$pkg_status" in
       0) #monitor exited with 0. fine. start a new one.
         packages/$package status >> log/$package.log 2>&1 & status_pid=$!
         healthy_timeout=$timeout
       ;;
       1) #package is down... clean stop it anyway.
         echo "$(date) package status is unexpectedly down!"
         packages/$package stop >> log/$package.log 2>&1 & stop_pid=$!
         pkg_state="failing"
       ;;
       2) #package is degraded... just wait for self healing.
         echo "$(date) package status degraded..."
         healthy_timeout=$((healthy_timeout-pace))
       ;;
       *) #a critical error has been detected. stop immediately.
         echo "$(date) package status is critical! manual intervention required!"
         packages/$package stop >> log/$package.log 2>&1 & stop_pid=$!
         pkg_state="halting"
       ;;
      esac
   else
      #monitor is taking some time... assume degraded
      healthy_timeout=$((healthy_timeout-pace))
   fi

   if [ $healthy_timeout -le 0 ] ; then
      echo "$(date) error: timeout waiting for package good health."
      packages/$package stop >> log/$package.log 2>&1 & stop_pid=$!
      pkg_state="failing"
   fi

   if [ "$pkg_state" = "running" -a "$stop" = "true" ] ; then
      packages/$package stop >> log/$package.log 2>&1 & stop_pid=$!
      pkg_state="halting"
   fi
}

_halting () {
   if ! kill -0 $stop_pid 2> /dev/null ; then
      wait $stop_pid
      if [ $? -eq 0 ] ; then
         [ "$pkg_state" = "failing" ] && pkg_state="failed"
         [ "$pkg_state" = "halting" ] && pkg_state="halted"
      else
         #if stop script returns error it's safer to quit
         echo "$(date) stop script exited with error."
         pkg_state="halted"
      fi
   else
      stop_timeout=$((stop_timeout-pace))
   fi

   if [ $stop_timeout -le 0 ] ; then
      echo "$(date) timeout waiting for package to stop."
      kill $stop_pid
      pkg_state="halted"
   fi
}

_halted () {
   if [ "$pkg_state" = "halted" ] ; then
      echo "$(date) package $pkg_state. exit."
      quit 0
   fi
   echo "$(date) package $pkg_state. restarting as stand-by."
   release-lock $package $timeout $timeout2
   sleep $pace
   role="stand-by"
}

_unknown () {
   if utils/pkill -0 -x -f "$shell_cmd packages/$package start" ; then
      echo "$(date) start script already running. package state is unknown."
      quit 1
   fi
   if utils/pkill -0 -x -f "$shell_cmd packages/$package stop" ; then
      echo "$(date) stop script already running. package state is unknown."
      quit 1
   fi

   #status function returns: 0 up, 1 down, 2 degraded
   packages/$package status >> log/$package.log 2>&1
   pkg_status=$?

   #status function returns: 0 up, 1 down, 2 degraded, 3 critical
   case "$pkg_status" in
    0|2)
      echo "$(date) package status is not down."
      packages/$package stop >> log/$package.log 2>&1 & stop_pid=$!
      pkg_state="failing"
    ;;

    1)
      packages/$package start >> log/$package.log 2>&1 & start_pid=$!
      pkg_state="starting"
    ;;

    *)
      echo "$(date) package status is critical! manual intervention required!"
      packages/$package stop >> log/$package.log 2>&1 & stop_pid=$!
      pkg_state="halting"
    ;;
   esac
}

###############################################

#avoid using built-in sleep in backgroud. it create a second back-to-work process
sleep_cmd=$(which sleep)

echo "$(date) starting as stand-by node." & sleep_pid=$!
while true ; do
   wait $sleep_pid ; $sleep_cmd $pace & sleep_pid=$!
   case $role in
    stand-by)
      [ "$stop" = "true" ] && quit 0
      if get-lock $package $timeout $timeout2 $pace ; then
         echo "$(date) got lock. switch to active node."
         healthy_timeout=$timeout
         start_timeout=$(packages/$package echo start_timeout)
         start_timeout=${start_timeout:-30}
         stop_timeout=$timeout2
         pkg_state="unknown"
         role="active"
      fi
    ;;

    active)
      if ! get-lock $package $timeout $timeout2 $pace ; then
         echo "$(date) lock lost. shutting down."
         stop="true"
      fi

      old_state=$pkg_state
      #using functions to speed up the parser (I hope :P)
      case $pkg_state in
       starting)        _starting ;;
       running)         _running ;;
       halting|failing) _halting ;;
       halted|failed)   _halted ;;
       unknown)         _unknown ;;
      esac # package_state

      if [ "$old_state" != "$pkg_state" ] ; then
         echo "$(date) package state changes to $pkg_state."
      fi
    ;;
   esac # role
done
